#!/bin/bash

# Accessibility Validation Script
# Usage: ./checkA11y domain.com

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

URL="$1"

if [ -z "$URL" ]; then
    echo -e "${RED}Usage: checkA11y domain.com${NC}"
    exit 1
fi

# Add https:// if no protocol specified
if [[ ! "$URL" =~ ^https?:// ]]; then
    URL="https://$URL"
fi

# Test connectivity with fallbacks
test_url() {
    if curl -s --head --max-time 10 "$1" > /dev/null 2>&1; then
        echo "$1"
        return 0
    fi
    return 1
}

echo -e "${BOLD}${BLUE}‚ôø Accessibility Analysis${NC}"
echo -e "${CYAN}=================================================${NC}"

# Test connectivity
FINAL_URL=""
if FINAL_URL=$(test_url "$URL"); then
    echo -e "${GREEN}‚úÖ Connected to: $FINAL_URL${NC}"
elif [[ ! "$URL" =~ ^https://www\. ]] && FINAL_URL=$(test_url "https://www.${URL#https://}"); then
    echo -e "${GREEN}‚úÖ Connected to: $FINAL_URL ${ORANGE}(with www prefix)${NC}"
else
    echo -e "${RED}‚ùå Error: Cannot reach $URL or www variant${NC}"
    exit 1
fi

echo ""

# Fetch HTML content
echo -e "${BOLD}Extracting and analyzing content...${NC}"
HTML_FILE=$(mktemp)
curl -s -L "$FINAL_URL" > "$HTML_FILE"

# Initialize counters
TOTAL_ERRORS=0
TOTAL_WARNINGS=0

echo ""

# ===== PAGE TITLE VALIDATION =====
echo -e "${BOLD}üìÑ Page Title Analysis${NC}"
echo -e "${CYAN}=====================${NC}"

TITLE=$(grep -o '<title[^>]*>[^<]*</title>' "$HTML_FILE" | sed 's/<title[^>]*>//; s/<\/title>//' | head -1)
TITLE_LENGTH=${#TITLE}

if [ -z "$TITLE" ]; then
    echo -e "${RED}‚ùå No <title> element found${NC}"
    ((TOTAL_ERRORS++))
elif [ "$TITLE_LENGTH" -eq 0 ]; then
    echo -e "${RED}‚ùå Page title is empty${NC}"
    ((TOTAL_ERRORS++))
else
    echo -e "${GREEN}‚úÖ Title exists:${NC} \"$TITLE\""
    echo -e "${CYAN}   Length: $TITLE_LENGTH characters${NC}"

    if [ "$TITLE_LENGTH" -lt 10 ]; then
        echo -e "${ORANGE}‚ö†Ô∏è  Title is very short (${TITLE_LENGTH} characters)${NC}"
        ((TOTAL_WARNINGS++))
    elif [ "$TITLE_LENGTH" -gt 60 ]; then
        echo -e "${ORANGE}‚ö†Ô∏è  Title is very long (${TITLE_LENGTH} characters)${NC}"
        ((TOTAL_WARNINGS++))
    fi
fi

echo ""

# ===== HEADING STRUCTURE VALIDATION =====
echo -e "${BOLD}üìã Heading Structure Analysis${NC}"
echo -e "${CYAN}==============================${NC}"

# Count headings
H1_COUNT=$(grep -c '<h1[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
H2_COUNT=$(grep -c '<h2[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
H3_COUNT=$(grep -c '<h3[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
H4_COUNT=$(grep -c '<h4[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
H5_COUNT=$(grep -c '<h5[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
H6_COUNT=$(grep -c '<h6[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)

# Ensure all are numeric
H1_COUNT=${H1_COUNT:-0}
H2_COUNT=${H2_COUNT:-0}
H3_COUNT=${H3_COUNT:-0}
H4_COUNT=${H4_COUNT:-0}
H5_COUNT=${H5_COUNT:-0}
H6_COUNT=${H6_COUNT:-0}

TOTAL_HEADINGS=$((H1_COUNT + H2_COUNT + H3_COUNT + H4_COUNT + H5_COUNT + H6_COUNT))

echo -e "${CYAN}üìä Headings found: h1=$H1_COUNT, h2=$H2_COUNT, h3=$H3_COUNT, h4=$H4_COUNT, h5=$H5_COUNT, h6=$H6_COUNT${NC}"
echo -e "${CYAN}üìù Total: $TOTAL_HEADINGS headings${NC}"

# Check H1 count
if [ "$H1_COUNT" -eq 0 ]; then
    echo -e "${RED}‚ùå No h1 element found on the page${NC}"
    ((TOTAL_ERRORS++))
elif [ "$H1_COUNT" -gt 1 ]; then
    echo -e "${RED}‚ùå Found $H1_COUNT h1 elements - only one h1 should exist per page${NC}"
    ((TOTAL_ERRORS++))
else
    echo -e "${GREEN}‚úÖ Exactly one h1 element found${NC}"
fi

# Check heading hierarchy order
if [ "$TOTAL_HEADINGS" -gt 0 ]; then
    echo -e "${CYAN}üîç Checking heading hierarchy order...${NC}"

    # Extract headings in document order with line numbers
    HEADINGS_ORDER=$(mktemp)
    grep -n '<h[1-6][^>]*>' "$HTML_FILE" | while IFS=':' read -r line_num heading_tag; do
        LEVEL=$(echo "$heading_tag" | grep -o 'h[1-6]' | sed 's/h//')
        echo "$line_num:$LEVEL"
    done > "$HEADINGS_ORDER"

    HIERARCHY_ERRORS=0
    PREV_LEVEL=0

    # Check each heading in order
    while IFS=':' read -r line_num level; do
        # Skip empty lines
        [ -z "$line_num" ] || [ -z "$level" ] && continue

        CURRENT_LEVEL="$level"

        # Ensure numeric values
        PREV_LEVEL=${PREV_LEVEL:-0}
        CURRENT_LEVEL=${CURRENT_LEVEL:-1}

        # First heading must be H1
        if [ "$PREV_LEVEL" -eq 0 ] && [ "$CURRENT_LEVEL" -ne 1 ] 2>/dev/null; then
            echo -e "${RED}‚ùå Line $line_num: First heading should be h1, found h$CURRENT_LEVEL${NC}"
            ((HIERARCHY_ERRORS++))
        fi

        # Cannot skip levels when going deeper
        if [ "$PREV_LEVEL" -gt 0 ] && [ "$CURRENT_LEVEL" -gt $((PREV_LEVEL + 1)) ] 2>/dev/null; then
            echo -e "${RED}‚ùå Line $line_num: Heading h$CURRENT_LEVEL skips level(s) after h$PREV_LEVEL${NC}"
            ((HIERARCHY_ERRORS++))
        fi

        PREV_LEVEL="$CURRENT_LEVEL"
    done < "$HEADINGS_ORDER"

    if [ "$HIERARCHY_ERRORS" -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Heading hierarchy follows proper order${NC}"
    else
        echo -e "${RED}‚ùå $HIERARCHY_ERRORS heading hierarchy error(s) found${NC}"
        TOTAL_ERRORS=$((TOTAL_ERRORS + HIERARCHY_ERRORS))
    fi

    rm -f "$HEADINGS_ORDER"
fi

# Check for empty headings (simplified)
EMPTY_HEADINGS=$(grep -o '<h[1-6][^>]*></h[1-6]>' "$HTML_FILE" | wc -l | tr -d ' ')
EMPTY_HEADINGS=${EMPTY_HEADINGS:-0}
if [ "$EMPTY_HEADINGS" -gt 0 ]; then
    echo -e "${ORANGE}‚ö†Ô∏è  $EMPTY_HEADINGS empty heading(s) found${NC}"
    TOTAL_WARNINGS=$((TOTAL_WARNINGS + EMPTY_HEADINGS))
fi

echo ""

# ===== IMAGE ALT TEXT VALIDATION =====
echo -e "${BOLD}üñºÔ∏è  Image Alt Text Analysis${NC}"
echo -e "${CYAN}===========================${NC}"

# Count images more accurately with better regex patterns
TOTAL_IMAGES=$(grep -o '<img[^>]*>' "$HTML_FILE" 2>/dev/null | wc -l | tr -cd '0-9' || echo 0)

# Count images with empty alt (alt="" or alt='')
IMAGES_WITH_EMPTY_ALT=$(grep -o '<img[^>]*alt=["'"'"']["'"'"'][^>]*>' "$HTML_FILE" 2>/dev/null | wc -l | tr -cd '0-9' || echo 0)

# Count images with any alt attribute (including empty ones)
IMAGES_WITH_ANY_ALT=$(grep -o '<img[^>]*alt=["\'"'"'][^>]*>' "$HTML_FILE" 2>/dev/null | wc -l | tr -cd '0-9' || echo 0)

# Images with descriptive alt = images with alt attribute minus images with empty alt
IMAGES_WITH_GOOD_ALT=$((IMAGES_WITH_ANY_ALT - IMAGES_WITH_EMPTY_ALT))

# Ensure all are numeric
TOTAL_IMAGES=${TOTAL_IMAGES:-0}
IMAGES_WITH_GOOD_ALT=${IMAGES_WITH_GOOD_ALT:-0}
IMAGES_WITH_EMPTY_ALT=${IMAGES_WITH_EMPTY_ALT:-0}

# Calculate images with any alt attribute (good or empty)
IMAGES_WITH_ALT_ATTR=$((IMAGES_WITH_GOOD_ALT + IMAGES_WITH_EMPTY_ALT))

# Images without alt attribute should never be negative
IMAGES_WITHOUT_ALT=$((TOTAL_IMAGES - IMAGES_WITH_ALT_ATTR))
if [ "$IMAGES_WITHOUT_ALT" -lt 0 ]; then
    IMAGES_WITHOUT_ALT=0
fi

echo -e "${CYAN}üìä Total images: $TOTAL_IMAGES${NC}"

if [ "$TOTAL_IMAGES" -gt 0 ]; then
    echo -e "${GREEN}‚úÖ Images with descriptive alt text: $IMAGES_WITH_GOOD_ALT${NC}"
    echo -e "${ORANGE}‚ö†Ô∏è  Images with empty alt text: $IMAGES_WITH_EMPTY_ALT (acceptable if decorative)${NC}"
    echo -e "${RED}‚ùå Images missing alt attribute: $IMAGES_WITHOUT_ALT${NC}"

    if [ "$IMAGES_WITHOUT_ALT" -gt 0 ]; then
        TOTAL_ERRORS=$((TOTAL_ERRORS + IMAGES_WITHOUT_ALT))
    fi

    if [ "$IMAGES_WITH_EMPTY_ALT" -gt 0 ]; then
        TOTAL_WARNINGS=$((TOTAL_WARNINGS + IMAGES_WITH_EMPTY_ALT))
    fi
else
    echo -e "${CYAN}No images found on the page${NC}"
fi

echo ""

# ===== FORM ACCESSIBILITY VALIDATION =====
echo -e "${BOLD}üìù Form Accessibility Analysis${NC}"
echo -e "${CYAN}=============================${NC}"

FORM_COUNT=$(grep -c '<form[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
INPUT_COUNT=$(grep -c '<input[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
LABEL_COUNT=$(grep -c '<label[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)

# Ensure all are numeric
FORM_COUNT=${FORM_COUNT:-0}
INPUT_COUNT=${INPUT_COUNT:-0}
LABEL_COUNT=${LABEL_COUNT:-0}

echo -e "${CYAN}üìä Forms: $FORM_COUNT, Inputs: $INPUT_COUNT, Labels: $LABEL_COUNT${NC}"

if [ "$INPUT_COUNT" -gt 0 ]; then
    # Basic check for input/label ratio
    if [ "$LABEL_COUNT" -lt "$INPUT_COUNT" ]; then
        MISSING_LABELS=$((INPUT_COUNT - LABEL_COUNT))
        echo -e "${ORANGE}‚ö†Ô∏è  Potential missing labels: $MISSING_LABELS inputs vs $LABEL_COUNT labels${NC}"
        TOTAL_WARNINGS=$((TOTAL_WARNINGS + MISSING_LABELS))
    else
        echo -e "${GREEN}‚úÖ Adequate label count for inputs${NC}"
    fi
else
    echo -e "${CYAN}No form inputs found${NC}"
fi

echo ""

# ===== LINK ACCESSIBILITY VALIDATION =====
echo -e "${BOLD}üîó Link Accessibility Analysis${NC}"
echo -e "${CYAN}=============================${NC}"

LINK_COUNT=$(grep -c '<a[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
LINK_COUNT=${LINK_COUNT:-0}
echo -e "${CYAN}üìä Total links: $LINK_COUNT${NC}"

if [ "$LINK_COUNT" -gt 0 ]; then
    # Check for potential empty links (basic)
    EMPTY_LINKS=$(grep -c '<a[^>]*></a>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
    EMPTY_LINKS=${EMPTY_LINKS:-0}
    if [ "$EMPTY_LINKS" -gt 0 ]; then
        echo -e "${RED}‚ùå $EMPTY_LINKS potentially empty links found${NC}"
        TOTAL_ERRORS=$((TOTAL_ERRORS + EMPTY_LINKS))
    else
        echo -e "${GREEN}‚úÖ No obviously empty links found${NC}"
    fi
fi

echo ""

# ===== LANGUAGE AND DOCTYPE VALIDATION =====
echo -e "${BOLD}üåê Language & Document Analysis${NC}"
echo -e "${CYAN}===============================${NC}"

# Check for DOCTYPE (case-insensitive)
if grep -qi '<!doctype html>' "$HTML_FILE"; then
    echo -e "${GREEN}‚úÖ HTML5 DOCTYPE found${NC}"
else
    echo -e "${RED}‚ùå Missing or invalid DOCTYPE${NC}"
    ((TOTAL_ERRORS++))
fi

# Check for lang attribute
if grep -q '<html[^>]*lang=' "$HTML_FILE"; then
    LANG_ATTR=$(grep -o '<html[^>]*lang="[^"]*"' "$HTML_FILE" | sed 's/.*lang="\([^"]*\)".*/\1/' | head -1)
    echo -e "${GREEN}‚úÖ Language attribute found: $LANG_ATTR${NC}"
else
    echo -e "${RED}‚ùå Missing lang attribute on html element${NC}"
    ((TOTAL_ERRORS++))
fi

# Check for viewport meta tag
if grep -q 'name="viewport"' "$HTML_FILE"; then
    echo -e "${GREEN}‚úÖ Viewport meta tag found${NC}"
else
    echo -e "${RED}‚ùå Missing viewport meta tag${NC}"
    ((TOTAL_ERRORS++))
fi

echo ""

# ===== SEMANTIC HTML VALIDATION =====
echo -e "${BOLD}üèóÔ∏è  Semantic HTML Analysis${NC}"
echo -e "${CYAN}==========================${NC}"

# Check for semantic elements
MAIN_COUNT=$(grep -c '<main[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
NAV_COUNT=$(grep -c '<nav[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
HEADER_COUNT=$(grep -c '<header[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
FOOTER_COUNT=$(grep -c '<footer[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
ARTICLE_COUNT=$(grep -c '<article[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)
SECTION_COUNT=$(grep -c '<section[^>]*>' "$HTML_FILE" 2>/dev/null | head -1 | tr -cd '0-9' || echo 0)

# Ensure all are numeric
MAIN_COUNT=${MAIN_COUNT:-0}
NAV_COUNT=${NAV_COUNT:-0}
HEADER_COUNT=${HEADER_COUNT:-0}
FOOTER_COUNT=${FOOTER_COUNT:-0}
ARTICLE_COUNT=${ARTICLE_COUNT:-0}
SECTION_COUNT=${SECTION_COUNT:-0}

SEMANTIC_TOTAL=$((MAIN_COUNT + NAV_COUNT + HEADER_COUNT + FOOTER_COUNT + ARTICLE_COUNT + SECTION_COUNT))

echo -e "${CYAN}üìä Semantic elements found: $SEMANTIC_TOTAL${NC}"
echo -e "${CYAN}   main: $MAIN_COUNT, nav: $NAV_COUNT, header: $HEADER_COUNT${NC}"
echo -e "${CYAN}   footer: $FOOTER_COUNT, article: $ARTICLE_COUNT, section: $SECTION_COUNT${NC}"

if [ "$MAIN_COUNT" -eq 0 ]; then
    echo -e "${ORANGE}‚ö†Ô∏è  No <main> element found - consider adding one${NC}"
    ((TOTAL_WARNINGS++))
elif [ "$MAIN_COUNT" -gt 1 ]; then
    echo -e "${ORANGE}‚ö†Ô∏è  Multiple <main> elements found - should be unique${NC}"
    ((TOTAL_WARNINGS++))
fi

if [ "$SEMANTIC_TOTAL" -eq 0 ]; then
    echo -e "${ORANGE}‚ö†Ô∏è  No semantic HTML5 elements found${NC}"
    ((TOTAL_WARNINGS++))
fi

echo ""

# ===== FINAL SUMMARY =====
echo -e "${BOLD}${PURPLE}üìä Accessibility Summary${NC}"
echo -e "${CYAN}=========================${NC}"

OVERALL_STATUS="PASS"
if [ "$TOTAL_ERRORS" -gt 0 ]; then
    OVERALL_STATUS="FAIL"
fi

echo -e "${CYAN}üìä Overall Status: ${NC}$([ "$OVERALL_STATUS" = "PASS" ] && echo -e "${GREEN}‚úÖ $OVERALL_STATUS${NC}" || echo -e "${RED}‚ùå $OVERALL_STATUS${NC}")"
echo -e "${CYAN}üî¢ Total Issues: ${NC}${RED}$TOTAL_ERRORS errors${NC}, ${ORANGE}$TOTAL_WARNINGS warnings${NC}"

echo ""

# ===== RECOMMENDATIONS =====
echo -e "${BOLD}${PURPLE}üí° Recommendations${NC}"
echo -e "${CYAN}==================${NC}"

if [ "$TOTAL_ERRORS" -gt 0 ]; then
    echo -e "${RED}‚Ä¢ Fix critical accessibility errors before deployment${NC}"
fi

if [ "$H1_COUNT" -eq 0 ]; then
    echo -e "${RED}‚Ä¢ Add exactly one h1 element to the page${NC}"
elif [ "$H1_COUNT" -gt 1 ]; then
    echo -e "${RED}‚Ä¢ Use only one h1 element per page${NC}"
fi

if [ "$IMAGES_WITHOUT_ALT" -gt 0 ]; then
    echo -e "${RED}‚Ä¢ Add alt attributes to all images${NC}"
fi

if [ "$IMAGES_WITH_EMPTY_ALT" -gt 0 ]; then
    echo -e "${ORANGE}‚Ä¢ Review images with empty alt text - ensure they are decorative${NC}"
fi

if [ "$SEMANTIC_TOTAL" -eq 0 ]; then
    echo -e "${ORANGE}‚Ä¢ Consider using semantic HTML5 elements (main, nav, header, footer, article, section)${NC}"
fi

if [ "$MAIN_COUNT" -eq 0 ]; then
    echo -e "${ORANGE}‚Ä¢ Add a <main> element to identify the primary content${NC}"
fi

if [ "$EMPTY_HEADINGS" -gt 0 ]; then
    echo -e "${ORANGE}‚Ä¢ Fix empty heading elements${NC}"
fi

# Check if we have heading hierarchy errors by testing the conditions again
HIERARCHY_HAS_ERRORS=false
if [ "$TOTAL_HEADINGS" -gt 0 ]; then
    # Quick check: if H2 exists but no H1, or H3 exists but no H2, etc.
    if [ "$H1_COUNT" -eq 0 ] && [ "$H2_COUNT" -gt 0 ]; then
        HIERARCHY_HAS_ERRORS=true
    elif [ "$H2_COUNT" -eq 0 ] && [ "$H3_COUNT" -gt 0 ]; then
        HIERARCHY_HAS_ERRORS=true
    elif [ "$H3_COUNT" -eq 0 ] && [ "$H4_COUNT" -gt 0 ]; then
        HIERARCHY_HAS_ERRORS=true
    fi
fi

if [ "$HIERARCHY_HAS_ERRORS" = true ]; then
    echo -e "${RED}‚Ä¢ Fix heading hierarchy - ensure proper nesting (h1‚Üíh2‚Üíh3‚Üíetc.)${NC}"
fi

echo -e "${GREEN}‚Ä¢ Test with screen readers and keyboard navigation${NC}"
echo -e "${GREEN}‚Ä¢ Validate with accessibility tools:${NC}"
echo -e "${CYAN}‚Ä¢ WAVE: https://wave.webaim.org/${NC}"
echo -e "${CYAN}‚Ä¢ axe DevTools: Browser extension for detailed analysis${NC}"
echo -e "${CYAN}‚Ä¢ Lighthouse Accessibility audit in Chrome DevTools${NC}"

echo ""

# Cleanup
rm -f "$HTML_FILE"

if [ "$TOTAL_ERRORS" -eq 0 ] && [ "$TOTAL_WARNINGS" -eq 0 ]; then
    echo -e "${BOLD}${GREEN}üéâ Excellent! No accessibility issues found.${NC}"
elif [ "$TOTAL_ERRORS" -eq 0 ]; then
    echo -e "${BOLD}${GREEN}‚úÖ No critical errors found, but check warnings above.${NC}"
else
    echo -e "${BOLD}${RED}‚ùå Critical accessibility issues found. Please fix the errors above.${NC}"
fi

echo -e "${BOLD}${GREEN}‚úÖ Accessibility analysis complete!${NC}"